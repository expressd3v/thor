require "thor"
require "open-uri"
require "fileutils"
require "yaml"
require "digest/md5"

class Thor::Util
  # @public
  def self.constant_to_thor_path(str)
    snake_case(str).squeeze(":")
  end

  # @public
  def self.constant_from_thor_path(str)
    make_constant(to_constant(str))
  end

  private
  # @private
  def self.to_constant(str)
    str.gsub(/:(.?)/) { "::#{$1.upcase}" }.gsub(/(?:^|_)(.)/) { $1.upcase }
  end
  
  # @private
  def self.make_constant(str)
    list = str.split("::")
    obj = Object
    list.each {|x| obj = obj.const_get(x) }
    obj
  end
  
  # @private
  def self.snake_case(str)
    return str.downcase if str =~ /^[A-Z]+$/
    str.gsub(/([A-Z]+)(?=[A-Z][a-z]?)|\B[A-Z]/, '_\&') =~ /_*(.*)/
      return $+.downcase
  end  
  
end

class Thor::Runner < Thor
  
  def self.globs_for(path)
    ["#{path}/Thorfile", "#{path}/*.thor", "#{path}/tasks/*.thor", "#{path}/lib/tasks/*.thor"]
  end

  def initialize_thorfiles
    thorfiles.each {|f| load f unless Thor.subclass_files.keys.include?(File.expand_path(f))}    
  end

  map "-T" => :list, "-i" => :install, "-u" => :update
  
  desc "install NAME", "install a Thor file into your system tasks"
  def install(name)
    initialize_thorfiles
    begin
      contents = open(name).read
    rescue OpenURI::HTTPError
      puts "The URI you provided: `#{name}' was invalid"
    rescue Errno::ENOENT
      puts "`#{name}' is not a valid file"
    end
    
    name = name =~ /\.thor$/ ? name : "#{name}.thor"
    
    thor_root = File.join(ENV["HOME"], ".thor")
    FileUtils.mkdir_p thor_root
    
    yaml_file = File.join(thor_root, "thor.yml")
    FileUtils.touch(yaml_file)
    yaml = YAML.load_file(yaml_file) || {}
    
    yaml[name] = Digest::MD5.hexdigest(name)
    
    File.open(yaml_file, "w") do |file|
      file.puts yaml.to_yaml
    end
    
    puts "Storing thor file in your system repository"
    
    File.open(File.join(thor_root, yaml[name] + ".thor"), "w") do |file|
      file.puts contents
    end
  end
  
  desc "update NAME", "update a Thor file from its original location"
  def update(name)
    
  end
  
  def installed
    Dir["#{ENV["HOME"]}/.thor/**/*.thor"].each do |f| 
      load f unless Thor.subclass_files.keys.include?(File.expand_path(f))
    end
    display_klasses
  end
  
  desc "list [SEARCH]", "list the available thor tasks"
  method_options :force => :boolean
  def list(search = "")
    initialize_thorfiles
    search = /.*#{search}.*/
    
    display_klasses
  end
    
  def method_missing(meth, *args)
    initialize_thorfiles
    meth = meth.to_s
    unless meth =~ /:/
      puts "Thor tasks must contain a :"
      return
    end
    
    thor_klass = meth.split(":")[0...-1].join(":")
    to_call = meth.split(":").last
    begin
      klass = Thor::Util.constant_from_thor_path(thor_klass)
    rescue NameError
      puts "There was no available namespace `#{thor_klass}'."
      return
    end
    
    unless klass.ancestors.include?(Thor)
      puts "`#{thor_klass}' is not a Thor module"
      return
    end
    
    ARGV.replace [to_call, *args].compact
    begin
      klass.start
    rescue ArgumentError
      puts "You need to call #{to_call} as `#{klass.usage_for_method(to_call)}'"
    rescue NoMethodError
      puts "`#{to_call}' is not available in #{thor_klass}"
    end
  end
  
  private
  def display_klasses
    klasses = Thor.subclasses.reject {|x| x == Thor::Runner}
    # Calculate the largest base class name
    max_base = klasses.max do |x,y| 
      Thor::Util.constant_to_thor_path(x.name).size <=> Thor::Util.constant_to_thor_path(y.name).size
    end.name.size
    
    # Calculate the size of the largest option description
    max_left_item = klasses.max do |x,y| 
      (x.help_list && x.help_list.max.usage + x.help_list.max.opt).to_i <=> 
      (y.help_list && y.help_list.max.usage + y.help_list.max.opt).to_i
    end
    
    max_left = max_left_item.help_list.max.usage + max_left_item.help_list.max.opt
        
    klasses.map {|k| k.help_list}.compact.each do |item|
      display_tasks(item, max_base, max_left)
    end    
  end  
  
  def display_tasks(item, max_base, max_left)
    base = Thor::Util.constant_to_thor_path(item.klass.name)
    item.usages.each do |name, usage|
      format_string = "%-#{max_left + max_base + 5}s"
      print format_string %
        "#{base}:#{item.usages.assoc(name).last} #{display_opts(item.opts.assoc(name) && item.opts.assoc(name).last)}"
      puts item.descriptions.assoc(name).last
    end    
  end
  
  def display_opts(opts)
    return "" unless opts
    opts.map do |opt, val|
      if val == true || val == "BOOLEAN"
        "[#{opt}]"
      elsif val == "REQUIRED"
        opt + "=" + opt.gsub(/\-/, "").upcase
      elsif val == "OPTIONAL"
        "[" + opt + "=" + opt.gsub(/\-/, "").upcase + "]"
      end
    end.join(" ")
  end  
  
  def thorfiles
    path = Dir.pwd
    system_thorfiles = Dir["#{ENV["HOME"]}/.thor/**/*.thor"]
    thorfiles = []
    
    # Look for Thorfile or *.thor in the current directory or a parent directory, until the root
    while thorfiles.empty?
      thorfiles = Dir[*Thor::Runner.globs_for(path)]
      path = File.dirname(path)
      break if path == "/"
    end
    thorfiles + system_thorfiles
  end
    
end

unless defined?(Spec)
  Thor::Runner.start
end